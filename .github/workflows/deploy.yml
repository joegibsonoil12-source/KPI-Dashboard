name: deploy
on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install required packages and supabase CLI
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          sudo apt-get update -y
          sudo apt-get install -y curl wget gnupg ca-certificates postgresql-client jq

          echo "Finding latest Supabase CLI release asset for Linux x86_64..."
          GH_API="https://api.github.com/repos/supabase/cli/releases/latest"
          RELEASE_JSON="/tmp/supabase_release.json"

          # Use the GITHUB_TOKEN if available for higher rate limits / auth, and request JSON explicitly.
          if [ -n "${GITHUB_TOKEN:-}" ]; then
            curl -sS -H "Accept: application/vnd.github+json" -H "Authorization: token ${GITHUB_TOKEN}" "$GH_API" -o "$RELEASE_JSON" || {
              echo "Failed to fetch release JSON from $GH_API"
              cat "$RELEASE_JSON" || true
              exit 1
            }
          else
            curl -sS -H "Accept: application/vnd.github+json" "$GH_API" -o "$RELEASE_JSON" || {
              echo "Failed to fetch release JSON from $GH_API"
              cat "$RELEASE_JSON" || true
              exit 1
            }
          fi

          # Validate JSON before feeding to jq
          if ! jq -e . "$RELEASE_JSON" >/dev/null 2>&1; then
            echo "ERROR: GitHub Releases API did not return valid JSON. Dumping response for diagnosis:"
            sed -n '1,200p' "$RELEASE_JSON" || true
            exit 1
          fi

          ASSET_URL=$(
            jq -r '.assets[]? | select(.name|test("linux|Linux"; "i") and (.name|test("x86_64|amd64"; "i"))) | .browser_download_url' \
              "$RELEASE_JSON" | head -n1 || true
          )

          # fallback: attempt some known filenames via release latest/download endpoint
          if [ -z "$ASSET_URL" ] || [ "$ASSET_URL" = "null" ]; then
            echo "No matching asset discovered in release JSON. Trying fallback asset names..."
            FALLBACK_NAMES=(
              "supabase_Linux_x86_64.tar.gz"
              "supabase_linux_x86_64.tar.gz"
              "supabase_linux_amd64.tar.gz"
              "supabase_$(uname -s)_x86_64.tar.gz"
            )
            for name in "${FALLBACK_NAMES[@]}"; do
              tryurl="https://github.com/supabase/cli/releases/latest/download/${name}"
              echo "Checking $tryurl ..."
              if curl -s -I -L "$tryurl" | head -n1 | grep -qi "200"; then
                ASSET_URL="$tryurl"
                break
              fi
            done
          fi

          if [ -z "$ASSET_URL" ] || [ "$ASSET_URL" = "null" ]; then
            echo "ERROR: Could not discover Supabase CLI asset URL from GitHub Releases or fallback names."
            exit 1
          fi

          echo "Downloading supabase CLI from: $ASSET_URL"
          curl -L --fail "$ASSET_URL" -o /tmp/supabase_cli_archive

          echo "Downloaded file info:"
          file /tmp/supabase_cli_archive || true
          ls -l /tmp/supabase_cli_archive

          if file /tmp/supabase_cli_archive | grep -qi 'gzip'; then
            sudo tar -xzf /tmp/supabase_cli_archive -C /usr/local/bin
          elif file /tmp/supabase_cli_archive | grep -qi 'XZ compressed'; then
            sudo tar -xJf /tmp/supabase_cli_archive -C /usr/local/bin
          else
            echo "Downloaded file is not a known tar format. Dumping head for diagnosis:"
            head -n 50 /tmp/supabase_cli_archive || true
            echo "ERROR: Unknown archive format, aborting."
            exit 1
          fi

          # Handle case where binary extracts to subdirectory
          if [ -f /usr/local/bin/supabase/supabase ]; then
            sudo mv /usr/local/bin/supabase/supabase /usr/local/bin/
            sudo rmdir /usr/local/bin/supabase || true
          fi

          sudo chmod +x /usr/local/bin/supabase || true
          echo "Supabase version:"
          /usr/local/bin/supabase --version || supabase --version || true

      - name: Login supabase CLI
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          set -e
          if [ -z "$SUPABASE_ACCESS_TOKEN" ]; then
            echo "SUPABASE_ACCESS_TOKEN is missing - add it to repo secrets"; exit 1
          fi
          supabase login --token "$SUPABASE_ACCESS_TOKEN"

      - name: Link supabase project
        env:
          SUPABASE_PROJECT_REF: ${{ secrets.SUPABASE_PROJECT_REF }}
        run: |
          set -e
          if [ -z "$SUPABASE_PROJECT_REF" ]; then
            echo "SUPABASE_PROJECT_REF is missing - add it to repo secrets"; exit 1
          fi
          supabase link --project-ref "$SUPABASE_PROJECT_REF"

      - name: Debug DB connectivity (psql)
        env:
          DATABASE_URL: ${{ secrets.SUPABASE_DB_URL }}
        run: |
          set -e
          echo "Running psql connectivity test..."
          if psql "$DATABASE_URL" -c "SELECT now();" ; then
            echo "PSQL OK: DB reachable and credentials accepted."
          else
            echo "PSQL failed — check SUPABASE_DB_URL / network / password"
            exit 1
          fi

      - name: Push DB migrations to Supabase
        env:
          DATABASE_URL: ${{ secrets.SUPABASE_DB_URL }}
        run: |
          set -e
          export DATABASE_URL="$DATABASE_URL"
          # try a few times to survive transient network failures
          ATTEMPTS=3
          for i in $(seq 1 $ATTEMPTS); do
            echo "supabase db push — attempt $i/$ATTEMPTS"
            if supabase db push; then
              echo "supabase db push: SUCCESS"
              break
            else
              echo "supabase db push: failed attempt $i"
              if [ "$i" -lt "$ATTEMPTS" ]; then
                echo "Sleeping 5s and retrying..."
                sleep 5
              else
                echo "supabase db push failed after $ATTEMPTS attempts"
                exit 1
              fi
            fi
          done
